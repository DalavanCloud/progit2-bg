[[C-git-commands]]
[appendix]
== Git команди

В книгата представихме много Git команди и се опитвахме това да бъде възможно най-информативно като постепенно добавяхме нови такива.
Обаче, това ни оставя с примери разпръснати из цялото съдържание.

В това приложение ще преминем накратко през всички изброени дотук Git команди и ще се постараем да ги групираме, доколкото е възможно, според предназначението им.
Ще говорим за това какво е общото предназначение на всяка команда и след това ще посочваме къде в книгата може да намерите примери с нея.


=== Настройки и конфигурация

Две от командите в Git се използват почти ежедневно, `config` и `help`.

==== git config

Git има начини за изпълнение по подразбиране на стотици операции.
За много от тях, можете да инструктирате Git да прави по подразбиране нещата по малко по-различен начин.
Това включва всичко, от това да кажете на Git какво е името ви до това да укажете специфични цветове в терминала или кой е редакторът ви, който предпоитате.
Тази команда чете и пише в няколко различни файла, така че можете да задавате стойности глобално или за определени хранилища.

Командата `git config` се използва в почти всяка глава от книгата.

В <<ch01-getting-started#_first_time>> я ползвахме за задаване на име и имейл на потребителя, както и за указване на текстовия ни редактор -- преди още да бяхме започнали да използваме Git.

В <<ch02-git-basics-chapter#_git_aliases>> показахме как бихте могли да я изпозлвате за създаването на съкратени варианти на команди, които автоматично се разширяват до пълните еквиваленти, така че да не се налага да ги въвеждате изцяло всеки път.

В <<ch03-git-branching#_rebasing>> използвахме командата за да направим `--rebase` опция по подразбиране при изпълнение на `git pull`.

В <<ch07-git-tools#_credential_caching>> я използвахме за определяне на default store за HTTP пароли.

В <<ch08-customizing-git#_keyword_expansion>> показахме как се създават smudge and clean филтри за съдържанието влизащо или излизащо от Git.

Почти всичко в <<ch08-customizing-git#_git_config>> е посветено на тази команда.

==== git help

Командата `git help` се използва за показване на документацията на командите в Git.
Ние правим кратък преглед тук, но ако искате пълния списък с всички възможни аргументи и флагове за коя да е команда, можете винаги да изпълните `git help <command>`.

Представихме `git help` в <<ch01-getting-started#_git_help>> и показахме как да я използвате за да намерите повече информация за `git shell` в <<ch04-git-on-the-server#_setting_up_server>>.


=== Издърпване и създаване на проекти

Има два начина за сдобиване с Git хранилище.
Единият е да го копираме от налично такова в мрежата или където и да се намира. Другият е да си го създадем от налична директория.

==== git init

За да вземем произволна директория и да я превърнем в Git хранилище, просто изпълняваме `git init`.

Показахме това първо в <<ch02-git-basics-chapter#_getting_a_repo>>, където създадохме ново хранилище, по което да работим.

Накратко споменахме как можем да сменим клона по подразбиране от ``master'' до друго име в  <<ch03-git-branching#_remote_branches>>.

Използваме тази команда и за създаване на празно bare хранилище на сървъра в <<ch04-git-on-the-server#_bare_repo>>.

Последно, погледнахме какво командата прави задкулисно в <<ch10-git-internals#_plumbing_porcelain>>.

==== git clone

Командата `git clone` по същество е нещо като wrapper около няколко други команди.
Тя създава нова директория, влиза в нея и изпълнява `git init` за да създаде празно Git хранилище, след това добавя remote (`git remote add`) към URL-а, който ѝ подавате (по подразбиране с име `origin`), изпълнява `git fetch` от това отдалечено хранилище и извлича в работната ви директория най-новия къмит с `git checkout`.

`git clone` се използва на цял куп места в книгата, ще изброим само най-интересните.

Командата бе представена и обяснена в <<ch02-git-basics-chapter#_git_cloning>>, където дадохме няколко примера.

В <<ch04-git-on-the-server#_getting_git_on_a_server>> погледнахме опцията `--bare` за създаване на Git хранилище без работна директория.

В <<ch07-git-tools#_bundling>> я използвахме за да възстановим пакетирано Git хранилище.

В <<ch07-git-tools#_cloning_submodules>> научихме за опцията `--recurse-submodules`, с чиято помощ улесняваме клонирането на хранилище с подмодули.

Въпреки, че командата се използва на много други места в книгата, гореизброените са тези, при които тя се използва по по-различен и специфичен начин.


=== Snapshotting

За основния работен процес по индексиране на съдържание и къмитването му в историята, съществуват само няколко основни команди.

==== git add

Командата `git add` добавя съдържание от работната директория в staging area (или ``индексната област'') за следващия къмит.
Когато се изпълни `git commit`, по подразбиране тя гледа какво има само в индекса, така `git add` се използва за определяне на това какво точно искате да включите в следващия snapshot.

Това е много важна за Git команда и се споменава десетки пъти в книгата.
Ето по-важните места.

Представихме `git add` първо в <<ch02-git-basics-chapter#_tracking_files>>.

Показахме как да я използваме за разрешаване на конфликти при сливане в <<ch03-git-branching#_basic_merge_conflicts>>.

Демонстрирахме как да я използваме интерактивно за да индексираме само специфични части от модифициран файл в <<ch07-git-tools#_interactive_staging>>.

Последно, емулирахме я на ниско ниво в <<ch10-git-internals#_tree_objects>>, така че да получите представа какво се случва под повърхността.

==== git status

Командата `git status` ще ви покаже различните статуси на файловете в работната директория и индексната област.
Кои файлове са променени и неиндексирани и кои са индексирани, но все още не са къмитнати.
В нормалната си форма, тя също така подава основни съвети за това как да премествате файлове между тези етапи.

Видяхме `status` за първи път <<ch02-git-basics-chapter#_checking_status>>.
Използваме я почти навсякъде в книгата, но почти всичко, което можете да вършите с нея е обяснено там.

==== git diff

Командата `git diff` се използва, когато искате да видите разликите между кои да е две дървета.
Това би могло да бъде разликата между работната област и индексната (което прави `git diff` без аргументи), между индексната област и последния къмит (`git diff --staged`), или между два къмита (`git diff master branchB`).

За пръв път срещнахме `git diff` в <<ch02-git-basics-chapter#_git_diff_staged>>, където показахме как да видим кои промени са индексирани и кои все още не са.

Използвахме я и за търсене на възможни whitespace проблеми преди къмитване с опцията `--check` в <<ch05-distributed-git#_commit_guidelines>>.

Видяхме как да проверим за разлики между клонове по ефективен начин използвайки синтаксиса `git diff A...B` в <<ch05-distributed-git#_what_is_introduced>>.

Използвахме я за да филтрираме whitespace разлики с флага `-b` а също и за сравнение на различни етапи от конфликтни файлове с `--theirs`, `--ours` и `--base` в <<ch07-git-tools#_advanced_merging>>.

Накрая, използвахме я за ефективно сравнение на submodule промени със `--submodule` опцията в <<ch07-git-tools#_starting_submodules>>.

==== git difftool

Командата `git difftool` просто стартира външен инструмент за показване на разликите между две дървета, в случай че предпочитате нещо различно от вградената `git diff`.

Споменахме я в <<ch02-git-basics-chapter#_git_diff_staged>>.

==== git commit

Командата `git commit` взема съдържанието на всички файлове индексирани преди това с `git add` и записва нов перманентен snapshot в базата данни, след което премества указателя на текущия клон към него.

Основите на къмитването показахме в <<ch02-git-basics-chapter#_committing_changes>>.
Там също така показахме как с удобния флаг `-a` можем да прескочим `git add` стъпката в ежедневния работен процес и как с `-m` да подадем къмит съобщението директно от командния ред вместо да пускаме редактора.

В <<ch02-git-basics-chapter#_undoing>> разгледахме опцията `--amend` за да направим отново последния къмит.

В <<ch03-git-branching#_git_branches_overview>> навлязохме в повече детайли за това какво прави `git commit` и защо го прави по дадения начин.

Видяхме как да подписваме къмити криптографски с флага `-S` в <<ch07-git-tools#_signing_commits>>.

Последно, погледнахме какво прави зад кулисите `git commit` и как това е имплементирано в <<ch10-git-internals#_git_commit_objects>>.

==== git reset

Командата `git reset` се използва основно за отмяна на действия, както подсказва името ѝ.
Тя премества указателя на `HEAD` и по избор може да променя индексната област, както и работната директория с опцията `--hard`.
Тази последна опция дава възможност за загуба на данни, ако се използва неправилно, така че трябва да я разберете добре преди да я ползвате.

За пръв път се срещнахме с простата форма на `git reset` в <<ch02-git-basics-chapter#_unstaging>>, където я използвахме за да извадим от индекса файл, върху който е изпълнена `git add`.

След това я разгледахме в повече детайли в <<ch07-git-tools#_git_reset>>, секцията беше изцяло посветена на нея.

Използвахме `git reset --hard` за да отменим сливане в <<ch07-git-tools#_abort_merge>>, където също така използвахме и `git merge --abort`, която е един вид wrapper за `git reset`.

==== git rm

Използваме `git rm` за изваждане на файлове от индексната област и работната директория в Git.
Тя е подобна на `git add` в това, че индексира файл (само че за изваждане) от следващия къмит.

Погледнахме я в малко детайли в <<ch02-git-basics-chapter#_removing_files>>, включително за  рекурсивно изтриване на файлове и също така за изтриване на файлове само от индекса, но не и от работната директория с опцията `--cached`.

Единственият вид различно приложение на `git rm` в книгата е в <<ch10-git-internals#_removing_objects>>, където използвахме и обяснихме опцията `--ignore-unmatch` при изпълнение на `git filter-branch`, която просто игнорира грешката, ако файлът който се опитваме да изтрием не съществува.
Това може да е полезно за ползване в скриптове.

==== git mv

Командата `git mv` е просто удобен заместител за ситуациите, когато трябва да преместите файл, да изпълните `git add` за новия файл и след това `git rm` за стария.

Само я споменахме накратко в <<ch02-git-basics-chapter#_git_mv>>.

==== git clean

Командата `git clean` се използва за премахване на нежелани файлове от работната директория.
Това може да включва премахването на временни обекти от компилиране или merge conflict файлове.

Разглеждаме много от опциите и сценариите, в които може да се използва clean командата в  <<ch07-git-tools#_git_clean>>.

=== Клонове и сливане

Само шепа команди имплементират по-голямата част от branching и merging функционалностите в Git.

==== git branch

`git branch` по същество е инструмент за управление на клоновете в Git.
Може да създава, изброява, изтрива и преименува клонове.

Повечето от <<ch03-git-branching#ch03-git-branching>> е посветено на `branch` командата и тя се използва в цялата глава.
Първо я представихме в <<ch03-git-branching#_create_new_branch>> и преминахме през повечето ѝ възможности (печатане и изтриване) в <<ch03-git-branching#_branch_management>>.

В <<ch03-git-branching#_tracking_branches>> използваме `git branch -u` за да укажем tracking клон.

Последно, погледнахме какво прави тя на заден план в <<ch10-git-internals#_git_refs>>.

==== git checkout

Командата `git checkout` се използва за превключване на клонове и за извличане на съдържание в работната директория.

За пръв път я срещнахме в <<ch03-git-branching#_switching_branches>> заедно с командата `git branch`.

Видяхме как да я използваме за да започнем да следим клонове с флага `--track` в <<ch03-git-branching#_tracking_branches>>.

Използваме я за повторно въвеждане на конфликти във файлове с опцията `--conflict=diff3` в <<ch07-git-tools#_checking_out_conflicts>>.

Навлизаме в по-дълбоки подробности за връзката ѝ с `git reset` в <<ch07-git-tools#_git_reset>>.

Детайли по имплементацията ѝ показахме в <<ch10-git-internals#ref_the_ref>>.

==== git merge

Инструментът `git merge` се използва за сливане на един или повече клонове в клона, който е текущо извлечен.
След сливането, текущият клон се премества напред с резултата от сливането.

Командата `git merge` видяхме за пръв път в <<ch03-git-branching#_basic_branching>>.
Въпреки, че се използва на различни места в книгата, тя има много малко на брой вариации -- в общи линии само `git merge <branch>` с името на единичен клон, който искаме да слеем.

Видяхме как се прави squashed сливане (където Git слива работата, но го прави под формата на единичен обединяващ къмит, вместо да записва цялата история на сливащия се клон) в края на  <<ch05-distributed-git#_public_project>>.

Преминахме през доста детайли по merge процеса и самата команда, включително `-Xignore-space-change` командата и флага `--abort` за отказ на проблематично сливане в <<ch07-git-tools#_advanced_merging>>.

Видяхме как да проверяваме сигнатури преди сливане, ако проектът ви използва GPG подписване в <<ch07-git-tools#_signing_commits>>.

Накрая научихме за Subtree сливането в <<ch07-git-tools#_subtree_merge>>.

==== git mergetool

Командата `git mergetool` служи за стартиране на външен merge helper в случай, че не харесвате вграденото сливане в Git.

Погледнахме го набързо в <<ch03-git-branching#_basic_merge_conflicts>> и навлязохме в детайли за това как да имплементирате собствен външен merge tool в <<ch08-customizing-git#_external_merge_tools>>.

==== git log

Командата `git log` се използва за показване на достъпна записана история на проект от най-късно записания къмит snapshot назад.
Тя по подразбиране ще покаже само историята на текущия клон, но може да ѝ се подадат различни или дори повече heads или клонове, от които да трасира.
Също често се използва за показване на разлики между два или повече клона на ниво къмит.

Тази команда се среща в почти всяка глава в книгата за демонстрация на различни аспекти от историята на проект.

Представихме я първо в <<ch02-git-basics-chapter#_viewing_history>>.
Там разгледахме аргументите ѝ `-p` и `--stat` за да получим представа какво е било въведено във всеки къмит, както и `--pretty` и `--oneline` опциите за да видим историята по-стегнато заедно с някои прости опции за филтриране по дата и автор.

В <<ch03-git-branching#_create_new_branch>> я използваме с аргумента `--decorate` за лесно визуализиране на това къде сочат указателите на клоновете, а също и с опцията `--graph` за да видим как изглеждат разклонени истории.

В <<ch05-distributed-git#_private_team>> и <<ch07-git-tools#_commit_ranges>> обяснихме синтаксиса `branchA..branchB` за да инструктираме `git log` да намери кои къмити са уникални за даден клон в сравнение с друг клон.
В <<ch07-git-tools#_commit_ranges>> разгледахме това сравнително обстойно.

В <<ch07-git-tools#_merge_log>> и <<ch07-git-tools#_triple_dot>> използваме формата  `branchA...branchB` и `--left-right` синтаксиса, за да видим какво е налично в един от двата клона, но не и в двата едновременно.
В <<ch07-git-tools#_merge_log>> също видяхме как да използваме `--merge` опцията за помощ при изследване на merge конфликти, както и `--cc` опцията за търсене на merge commit конфликти в историята.

В <<ch07-git-tools#_git_reflog>> демонстрирахме флага `-g` за да видим Git reflog-а през този инструмент вместо да правим branch traversal.

В <<ch07-git-tools#_searching>> използвахме флаговете `-S` и `-L` за търсене на неща, които са се случили хронологично в кода във времето, например историята на дадена функция.

В <<ch07-git-tools#_signing_commits>> виждаме как да използваме `--show-signature` за да добавим верификационен стринг към всеки къмит в изхода от `git log` в зависимост от това дали той е валидно подписан или не.

==== git stash

Командата `git stash` се използва за временно съхранение/скриване на некъмитната работа с цел да се изчисти работната директория без да е необходимо къмитване на недовършената работа в клона.

Това е обяснено изцяло в <<ch07-git-tools#_git_stashing>>.

==== git tag

`git tag` командата предоставя възможност за създаване на перманентен маркер (bookmark) към специфична точка в историята на кода.
В общи линии се използва за маркиране на неща от рода на releases.

Тази команда е представена и разгледана в подробности в <<ch02-git-basics-chapter#_git_tagging>> и я използваме в действие в <<ch05-distributed-git#_tagging_releases>>.

Погледнахме как да създадем GPG signed таг с флага `-s` и също така как да проверим такъв с `-v` в <<ch07-git-tools#_signing>>.


=== Споделяне и обновяване на проекти

Не са много командите в Git, които правят мрежови операции, почти всички работят с локалната база данни.
Когато сте готови да споделите работата си обаче, ето какви са възможностите:

==== git fetch

`git fetch` комуникира с отдалечено хранилище и издърпва всичката информация от него, която липсва в локалната база данни.

Представихме я в <<ch02-git-basics-chapter#_fetching_and_pulling>> и продължихме с примери за нея в <<ch03-git-branching#_remote_branches>>.

Използвахме я и в няколко примера в <<ch05-distributed-git#_contributing_project>>.

Използваме я за издърпваме на конкретна референция, която е извън областта по подразбиране в <<ch06-github#_pr_refs>> и видяхме как да издърпваме от bundle в <<ch07-git-tools#_bundling>>.

Направихме строго потребителски refspecs с цел да накараме `git fetch` да направи нещо малко по-различно от подразбиращото се в <<ch10-git-internals#_refspec>>.

==== git pull

Командата `git pull` по същество е комбинация от `git fetch` и `git merge` командите като Git ще се опита да изтегли и слее промените от отдалеченото хранилище в една стъпка.

Представихме я първоначално в <<ch02-git-basics-chapter#_fetching_and_pulling>> и демонстрирахме как да видим какво ще бъде слято, ако бъде изпълнена в <<ch02-git-basics-chapter#_inspecting_remote>>.

Видяхме как да я използваме в помощ при rebasing затруднения в <<ch03-git-branching#_rebase_rebase>>.

Показваме как да я използваме с URL за да интегрираме промени в one-off маниер в <<ch05-distributed-git#_checking_out_remotes>>.

Набързо отбелязваме, че може да използвате опцията `--verify-signatures` за да проверите дали къмитите, които интегрирате са били GPG подписани в <<ch07-git-tools#_signing_commits>>.

==== git push

The `git push` command is used to communicate with another repository, calculate what your local database has that the remote one does not, and then pushes the difference into the other repository.
It requires write access to the other repository and so normally is authenticated somehow.

We first look at the `git push` command in <<ch02-git-basics-chapter#_pushing_remotes>>.
Here we cover the basics of pushing a branch to a remote repository.
In <<ch03-git-branching#_pushing_branches>> we go a little deeper into pushing specific branches and in <<ch03-git-branching#_tracking_branches>> we see how to set up tracking branches to automatically push to.
In <<ch03-git-branching#_delete_branches>> we use the `--delete` flag to delete a branch on the server with `git push`.

Throughout <<ch05-distributed-git#_contributing_project>> we see several examples of using `git push` to share work on branches through multiple remotes.

We see how to use it to share tags that you have made with the `--tags` option in <<ch02-git-basics-chapter#_sharing_tags>>.

In <<ch07-git-tools#_publishing_submodules>> we use the `--recurse-submodules` option to check that all of our submodules work has been published before pushing the superproject, which can be really helpful when using submodules.

In <<ch08-customizing-git#_other_client_hooks>> we talk briefly about the `pre-push` hook, which is a script we can setup to run before a push completes to verify that it should be allowed to push.

Finally, in <<ch10-git-internals#_pushing_refspecs>> we look at pushing with a full refspec instead of the general shortcuts that are normally used.
This can help you be very specific about what work you wish to share.

==== git remote

The `git remote` command is a management tool for your record of remote repositories.
It allows you to save long URLs as short handles, such as ``origin'' so you don't have to type them out all the time.
You can have several of these and the `git remote` command is used to add, change and delete them.

This command is covered in detail in <<ch02-git-basics-chapter#_remote_repos>>, including listing, adding, removing and renaming them.

It is used in nearly every subsequent chapter in the book too, but always in the standard `git remote add <name> <url>` format.

==== git archive

The `git archive` command is used to create an archive file of a specific snapshot of the project.

We use `git archive` to create a tarball of a project for sharing in <<ch05-distributed-git#_preparing_release>>.

==== git submodule

The `git submodule` command is used to manage external repositories within a normal repositories.
This could be for libraries or other types of shared resources.
The `submodule` command has several sub-commands (`add`, `update`, `sync`, etc) for managing these resources.

This command is only mentioned and entirely covered in <<ch07-git-tools#_git_submodules>>.

=== Inspection and Comparison

==== git show

The `git show` command can show a Git object in a simple and human readable way.
Normally you would use this to show the information about a tag or a commit.

We first use it to show annotated tag information in <<ch02-git-basics-chapter#_annotated_tags>>.

Later we use it quite a bit in <<ch07-git-tools#_revision_selection>> to show the commits that our various revision selections resolve to.

One of the more interesting things we do with `git show` is in <<ch07-git-tools#_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

==== git shortlog

The `git shortlog` command is used to summarize the output of `git log`.
It will take many of the same options that the `git log` command will but instead of listing out all of the commits it will present a summary of the commits grouped by author.

We showed how to use it to create a nice changelog in <<ch05-distributed-git#_the_shortlog>>.

==== git describe

The `git describe` command is used to take anything that resolves to a commit and produces a string that is somewhat human-readable and will not change.
It's a way to get a description of a commit that is as unambiguous as a commit SHA-1 but more understandable.

We use `git describe` in <<ch05-distributed-git#_build_number>> and <<ch05-distributed-git#_preparing_release>> to get a string to name our release file after.


=== Debugging

Git has a couple of commands that are used to help debug an issue in your code.
This ranges from figuring out where something was introduced to figuring out who introduced it.

==== git bisect

The `git bisect` tool is an incredibly helpful debugging tool used to find which specific commit was the first one to introduce a bug or problem by doing an automatic binary search.

It is fully covered in <<ch07-git-tools#_binary_search>> and is only mentioned in that section.

==== git blame

The `git blame` command annotates the lines of any file with which commit was the last one to introduce a change to each line of the file and what person authored that commit.
This is helpful in order to find the person to ask for more information about a specific section of your code.

It is covered in <<ch07-git-tools#_file_annotation>> and is only mentioned in that section.

==== git grep

The `git grep` command can help you find any string or regular expression in any of the files in your source code, even older versions of your project.

It is covered in <<ch07-git-tools#_git_grep>> and is only mentioned in that section.

=== Patching

A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
These commands help you manage your branches in this manner.

==== git cherry-pick

The `git cherry-pick` command is used to take the change introduced in a single Git commit and try to re-introduce it as a new commit on the branch you're currently on.
This can be useful to only take one or two commits from a branch individually rather than merging in the branch which takes all the changes.

Cherry picking is described and demonstrated in <<ch05-distributed-git#_rebase_cherry_pick>>.

==== git rebase

The `git rebase` command is basically an automated `cherry-pick`.
It determines a series of commits and then cherry-picks them one by one in the same order somewhere else.

Rebasing is covered in detail in <<ch03-git-branching#_rebasing>>, including covering the collaborative issues involved with rebasing branches that are already public.

We use it in practice during an example of splitting your history into two separate repositories in <<ch07-git-tools#_replace>>, using the `--onto` flag as well.

We go through running into a merge conflict during rebasing in <<ch07-git-tools#ref_rerere>>.

We also use it in an interactive scripting mode with the `-i` option in <<ch07-git-tools#_changing_multiple>>.

==== git revert

The `git revert` command is essentially a reverse `git cherry-pick`.
It creates a new commit that applies the exact opposite of the change introduced in the commit you're targeting, essentially undoing or reverting it.

We use this in <<ch07-git-tools#_reverse_commit>> to undo a merge commit.

=== Email

Many Git projects, including Git itself, are entirely maintained over mailing lists.
Git has a number of tools built into it that help make this process easier, from generating patches you can easily email to applying those patches from an email box.

==== git apply

The `git apply` command applies a patch created with the `git diff` or even GNU diff command.
It is similar to what the `patch` command might do with a few small differences.

We demonstrate using it and the circumstances in which you might do so in <<ch05-distributed-git#_patches_from_email>>.

==== git am

The `git am` command is used to apply patches from an email inbox, specifically one that is mbox formatted.
This is useful for receiving patches over email and applying them to your project easily.

We covered usage and workflow around `git am` in <<ch05-distributed-git#_git_am>> including using the `--resolved`, `-i` and `-3` options.

There are also a number of hooks you can use to help with the workflow around `git am` and they are all covered in <<ch08-customizing-git#_email_hooks>>.

We also use it to apply patch formatted GitHub Pull Request changes in <<ch06-github#_email_notifications>>.

==== git format-patch

The `git format-patch` command is used to generate a series of patches in mbox format that you can use to send to a mailing list properly formatted.

We go through an example of contributing to a project using the `git format-patch` tool in <<ch05-distributed-git#_project_over_email>>.

==== git imap-send

The `git imap-send` command uploads a mailbox generated with `git format-patch` into an IMAP drafts folder.

We go through an example of contributing to a project by sending patches with the `git imap-send` tool in <<ch05-distributed-git#_project_over_email>>.

==== git send-email

The `git send-email` command is used to send patches that are generated with `git format-patch` over email.

We go through an example of contributing to a project by sending patches with the `git send-email` tool in <<ch05-distributed-git#_project_over_email>>.

==== git request-pull

The `git request-pull` command is simply used to generate an example message body to email to someone.
If you have a branch on a public server and want to let someone know how to integrate those changes without sending the patches over email, you can run this command and send the output to the person you want to pull the changes in.

We demonstrate how to use `git request-pull` to generate a pull message in <<ch05-distributed-git#_public_project>>.

=== External Systems

Git comes with a few commands to integrate with other version control systems.

==== git svn

The `git svn` command is used to communicate with the Subversion version control system as a client.
This means you can use Git to checkout from and commit to a Subversion server.

This command is covered in depth in <<ch09-git-and-other-systems#_git_svn>>.

==== git fast-import

For other version control systems or importing from nearly any format, you can use `git fast-import` to quickly map the other format to something Git can easily record.

This command is covered in depth in <<ch09-git-and-other-systems#_custom_importer>>.

=== Administration

If you're administering a Git repository or need to fix something in a big way, Git provides a number of administrative commands to help you out.

==== git gc

The `git gc` command runs ``garbage collection'' on your repository, removing unnecessary files in your database and packing up the remaining files into a more efficient format.

This command normally runs in the background for you, though you can manually run it if you wish.
We go over some examples of this in <<ch10-git-internals#_git_gc>>.

==== git fsck

The `git fsck` command is used to check the internal database for problems or inconsistencies.

We only quickly use this once in <<ch10-git-internals#_data_recovery>> to search for dangling objects.

==== git reflog

The `git reflog` command goes through a log of where all the heads of your branches have been as you work to find commits you may have lost through rewriting histories.

We cover this command mainly in <<ch07-git-tools#_git_reflog>>, where we show normal usage to and how to use `git log -g` to view the same information with `git log` output.

We also go through a practical example of recovering such a lost branch in <<ch10-git-internals#_data_recovery>>.

==== git filter-branch

The `git filter-branch` command is used to rewrite loads of commits according to certain patterns, like removing a file everywhere or filtering the entire repository down to a single subdirectory for extracting a project.

In <<ch07-git-tools#_removing_file_every_commit>> we explain the command and explore several different options such as `--commit-filter`, `--subdirectory-filter` and `--tree-filter`.

In <<ch09-git-and-other-systems#_git_p4>> and <<ch09-git-and-other-systems#_git_tfs>> we use it to fix up imported external repositories.


=== Plumbing Commands

There were also quite a number of lower level plumbing commands that we encountered in the book.

The first one we encounter is `ls-remote` in <<ch06-github#_pr_refs>> which we use to look at the raw references on the server.

We use `ls-files` in <<ch07-git-tools#_manual_remerge>>, <<ch07-git-tools#ref_rerere>> and <<ch07-git-tools#_the_index>> to take a more raw look at what your staging area looks like.

We also mention `rev-parse` in <<ch07-git-tools#_branch_references>> to take just about any string and turn it into an object SHA-1.

However, most of the low level plumbing commands we cover are in <<ch10-git-internals#ch10-git-internals>>, which is more or less what the chapter is focused on.
We tried to avoid use of them throughout most of the rest of the book.
